<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="lblBodyRules.Text" xml:space="preserve">
    <value>Hay varias formas de decidir quién inicia el juego, una puede ser que cada jugador arroje un dado, el que obtenga el número más alto será el que comience. Una segunda es que cada jugador tire los cinco dados, el que obtenga la suma más baja es el que iniciará. Adicionalmente el que quede en segundo lugar se sentará a su izquierda y así sucesivamente. El orden del juego sigue la dirección de la mano derecha, al contrario de las agujas del reloj.</value>
  </data>
  <data name="lblSummary.Text" xml:space="preserve">
    <value>La generala es un juego de dados. Se juega con cinco dados y con un cubilete; el número de jugadores es ilimitado, pero lo óptimo es de 3 a 5. El objetivo del juego es lograr el mayor puntaje, de acuerdo a una valorización establecida para cada jugada posible en el juego, llamada categoría.</value>
  </data>
  <data name="lblCategory.Text" xml:space="preserve">
    <value>Para calcular el puntaje correspondiente a una categoría de números del 1 al 6, se deben sumar los números iguales. Por ejemplo, si un jugador, tirara tres dados con el número 6, se sumará, 6+6+6=18, este resultado se anotará en la casilla correspondiente al número 6. Si son tres 1 se debe anotar 3 al 1, si hay dos 6 se debe anotar 12 al 6.</value>
  </data>
  <data name="lblNotes.Text" xml:space="preserve">
    <value>Una vez lograda una categoría esta se considera "Cerrada", es decir, si el jugador la repite no la podrá usar, de tal forma que tendrá que buscar otra posible categoría con la combinación de dados obtenida. Por ejemplo, si el jugador tira 4-4-2-2-2, si ya había anotado el full, puede anotar la tirada en la categoría del 4 o del 2.</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>Existen 10 posibles categorías, por lo tanto cada jugador tendrá 11 tiros posibles en el juego. Cada tirada consiste en el lanzamiento de los cinco dados,​ de acuerdo a los números salientes se puede armar una categoría, si no logró alcanzar una categoría satisfactoria en el primer lanzamiento, se puede apartar los dados útiles y tomar los demás y tirarlos por segunda vez, en esta segunda tirada puede apartar los más convenientes y juntarlos con los que ya tenía apartados y luego tirará el resto por tercera y última con lo que termina la tirada. Si en un único tiro se logró una categoría, a esto se lo llama «tiro servido» (sólo aplicará para los juegos mayores, ver más adelante). Esto puede ocurrir en cualquiera de los tres tiros de cada turno, no necesariamente en el primero, siempre y cuando se lancen los 5 dados en ese tiro. El puntaje se obtiene en relación a la categoría que se arma con la combinación de los 5 dados.</value>
  </data>
  <data name="label3.Text" xml:space="preserve">
    <value>Para anotar la puntuación de cada jugador, se debe armar una planilla anotando las once categorías posibles en filas, que van de la categoría 1 a la 6 y luego las categorías que se llaman "Juegos mayores" que son escalera, full, póquer, generala y doble generala (esta última se puede omitir, con acuerdo de los jugadores con lo que entonces serían diez categorías y serían diez tiros por jugador) y en los encabezados formando columnas verticales se colocan los nombres de los jugadores.</value>
  </data>
</root>